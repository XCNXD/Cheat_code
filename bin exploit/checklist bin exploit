$trick
#solve
-title
-------------------

$$ เก็บข้อมูลทั้งหมดที่ค้นเจอ $$

Check all client string
 - Flag
 - hash 
 - encode
 - another sus string
  # ถ้าเจอทั้งหมดที่ว่ามาลองเช็ค reference การทำงานก่อน ว่าได้ใช้อะไรหรือไม่ บางทีอาจจะเป็น flag หลอก หรืออาจะเป็น encrypted flag

Find where do we get flag
  $ มีความเป็นไปได้หลายรูปแบบมาก เช่น ใช้ช่องโหว่ของการ Buffer overflow เพื่อแทนที่ค่าอะไรสักอย่าง หรือ Format string attack เพื่อ leak ข้อมูล
  $ แต่อย่าลืมว่า ยังมีช่องโหว่อื่นอีกเยอะแยะเช่นการ Patch Binary, integer overflow ที่อยู่ภายนอก decompiler ของ C เพราะฉนั้น ต้องสักเกตให้ดีก่อน!
  - หา input/output function แล้วดูช่องโหว่ของ input นั้นๆ
    - gets : http://cwe.mitre.org/data/definitions/242.html
       $ gets อ่าน byte ไปเรื่อยๆแบบ ไม่จำกัด byte ที่เราใส่เข้าไปและหยุดอ่านที่ \x00 หรือ Null byte 
       # ทำให้เกิดช่องโหว่ Buffer overflow บน stack ได้
    - fgets 
       $ เหมือนกันกับ gets แต่รับ byte เท่าที่ทำหนดไว้เท่านั้น
       $ char *fgets(char s[restrict .size], int size, FILE *restrict stream);
       $ แต่เมื่อเราคำนวนขนาดของ stack ผ่าน assembly code แล้ว (sub rsp, size) มันมีค่าน้อยกกว่า size ของ fgets ที่กำหนดเอาไว้
       # สามารถเกิด buffer overflow ได้ ^
       # รับ string format ได้ ทำให้เกิด string format vulnerability (ต้องรอดู output ตามฟังชั่นด้านล่างอีกที)
    - scanf, printf ,sprint, 
       $

    - other stdin 
       # https://seb-sec.github.io/2020/04/29/file_exploitation.html 
       #https://github.com/CptGibbon/House-of-Corrosion
    - getenv


Common Memory/Pointer exploit in C : https://www.geeksforgeeks.org/common-memory-pointer-related-bug-in-c-programs/
Linux Privillege Escalation : https://loveleshgangil.medium.com/linux-privilege-escalation-checklist-6ccfb13b11ca
