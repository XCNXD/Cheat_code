$trick
#solve
-title
-------------------

$$ เก็บข้อมูลทั้งหมดที่ค้นเจอ $$

Check all client string
 - Flag
 - hash 
 - encode
 - another sus string
  # ถ้าเจอทั้งหมดที่ว่ามาลองเช็ค reference การทำงานก่อน ว่าได้ใช้อะไรหรือไม่ บางทีอาจจะเป็น flag หลอก หรืออาจะเป็น encrypted flag
Check Sec File to Identify Vulnerability, ASLR(Address space layout randomization)
	- RELRO (Relocation-Only)
		 $ relro หรือ relocation read only คือ ระบบความปลอดภัย ที่เป็น linker 
		- No RELRO
			 # ปกติดีทุกอย่าง
		- Partial RELRO
			 # Got จะโหลดขึ้นมาก่อน data section ทำให้ยากที่จะ buffer overflow เข้าไปแก้ไข
			 # แต่ยังไงก็เถอะ มันก็ยังโดนเขียนทับได้อยู่ดีนั้นแหละ
		- Full RELRO
			 # ยังไม่มี bypass ในบัจจุบัน
	- Stack Canary
			 $ คือการที่ตัวโปรแกรมจะกำหนด byte 4/8 byte ตาม x86/x64 ไปใส่เอาไว้ด้านบน return address บน stack 
			 $ และก่อนจบ section จะเช็คว่า stack canary ยังเหมือนเดิมอยู่ไหม ถ้าไม่ก็จะ break ออกทันที
			 $ และเมื่อเราจะทำการ buffer overflow เพื่อควบคุม control flow เราจะต้องใส่ buff ให้เลยลงไปจนทับ return address ใช่มะ
			 $ แต่เมื่อเราทำอย่างงั้น stack canary ก็จะถูกทับตามไปด้วย ขั้นตอนการเช็คก็จะfail และเรียกใช้ stack_check_fail ครับ
			 # bruthforce / leak stack canary / หาที่เปลี่ยน function pointer ที่อื่นเช่น got
	- NX (No-eXcution)
		 $ ป้องกันการ execute บนพื้นที่แปลกๆใน memory โดยการให้ permission การ X บนช่วง instruction เท่านั้น
		 $ อย่างที่รู้ๆกันเลยครับ ว่า computer จะอ่านข้อมูลทุกอย่าง ไม่ว่าจะเป็น instruction หรือ data ออกมาเป็น binrary
		 $ เพราะฉนั้น stack ที่เป็นพื้นที่เก็บ data จึงสามารถเก็บ instruction และสามารถรันโค้ดได้ วิธีการก็จะเป็นการเปลี่ยน control flow ให้ jump เข้าที่stack ที่ๆใส่shellcode ไว้
		 $ ก็นั่นแหละครับ ทำไมถึงต้องมี NX 
	- PIE (Position Independent Executable)
		 $ สุ่ม load binary ไปแบบมั่วๆ บน ram ทำให้ main address,global variable ใน binary ไม่เหมือนเดิม และทำROP ได้ยากขึ้น
		 # leak base address ของ libc/etc
 
	- RPATH (Runtime Seach Path)?

	- FORTIFY?
 # หลังจากหา flag ใน client แล้ว เราไม่พบ flag ให้สังเกตฟังชั่นที่เรียกใช้ แล้วพิจารณาว่ามี flag อยู่บน stack
	 # ถ้าเป็น cat flag.txt ให้solve instruction ตามที่เค้าต้องการ
	 # ถ้าไม่มีฟังชั่นไหนที่ให้ flag หรือ อ่านflagออกมาเลย ให้ shell code/rop เพื่อทำ shell
	 # ถ้ามีฟังชั่นเรียกใช้ เอา flag ออกมา แล้วไม่ได้ถูกเรียกใช้ ให้ buffer overflow return address หรือ rop
	 # ถ้ามีอยู่บน stack จากการเรียกใช้ fopen หรือ อื่นๆที่อ่าน flag 
	   # หา string format vulnerability เพื่อ leak ค่าบน stack โดยใช้ %x
			 %10$x ดูค่าใน stack ที่ ช่อง 10 (%x)(%lx)(%hx) 
  # เช็ค stack canary 
		# ถ้าเกิดว่ามี ให้ดูว่าสามารถ bypass aslr หรือ leak อะไรได้ไหม
    # ถ้า leak ไม่ได้ ให้คิดไอเดียการใช้ rop,ret2libc,ret2got เพื่อเปลี่ยน control flow ด้านใน
		# ถ้า leak ได้ อาจจะต้องพิจารณาว่าเราต้องใช้ช่องโหว่bufferนี้หรือไม่
  # เช็คRELRO 
		# Full relro ตัดความเป็นไปได้ของการเปลี่ยน function pointer ใน got ไปเลย
	# เช็ค NX
		# ถ้าปิดไว้ เป็นไปได้ว่าจะต้องทำ shell code ลงไปบน stack
	# เช็ค PIE 
		#ถ้าเปิดไว้ หา base address ของ module นั้นๆให้ได้เพื่อจะทำอะไรก็แล้วแต่ 
Find where do we get flag
  $ มีความเป็นไปได้หลายรูปแบบมาก เช่น ใช้ช่องโหว่ของการ Buffer overflow เพื่อแทนที่ค่าอะไรสักอย่าง หรือ Format string attack เพื่อ leak ข้อมูล
  $ แต่อย่าลืมว่า ยังมีช่องโหว่อื่นอีกเยอะแยะเช่นการ Patch Binary, integer overflow ที่อยู่ภายนอก decompiler ของ C เพราะฉนั้น ต้องสักเกตให้ดีก่อน!
  - หา input/output function และ dangerous function อื่นๆ แล้วดูช่องโหว่ของ input นั้นๆ : 
    - gets : http://cwe.mitre.org/data/definitions/242.html
       $ gets อ่าน byte ไปเรื่อยๆแบบ ไม่จำกัด byte ที่เราใส่เข้าไปและหยุดอ่านที่ \x00 หรือ Null byte 
       # ทำให้เกิดช่องโหว่ Buffer overflow บน stack ได้
    - fgets 
       $ เหมือนกันกับ gets แต่รับ byte เท่าที่ทำหนดไว้เท่านั้น
       $ char *fgets(char s[restrict .size], int size, FILE *restrict stream);
       $ แต่เมื่อเราคำนวนขนาดของ stack ผ่าน assembly code แล้ว (sub rsp, size) มันมีค่าน้อยกกว่า size ของ fgets ที่กำหนดเอาไว้
       # สามารถเกิด buffer overflow ได้ ^
    - printf ,sprint, printf, fprintf, sprintf, snprinf, vfprintf, vprintf,vsprintf,vsnprintf, syslog
       $ ฟังชั่นพื้นฐานธรรมดาที่ใครๆก็รู้จัก ที่เมื่อเราใส่ string อะไรก็ตามเข้าไปในนั้นมันก็จะออกมาในหน้า console หรือ output
       $ แต่ว่าฟังชั่นตัวนี้ ก็ทำอะไรให้มันลำบากมากขึ้นเมื่อเราจะนำตัวแปรมาใช้งาน เราจำเป็นต้องมีสิ่งที่เรียกว่า "format string"
       $ และเมื่อเราสามารถควบคุม format stringได้ เราก็สามารถใช้ format ที่สามารถ leak ข้อมูลได้ เรียกช่องโหว่นี้ว่า
       # format string attack
    - strcpy
       $ load ค่าจากตัวแปรอีกตัวนึง ไปยังตัวแปรอีกตัวนึง โดยไม่สนใจขนาด
       # และทำให้เกิด Buffer overflow
    - other stdin 
       # https://seb-sec.github.io/2020/04/29/file_exploitation.html 
       #https://github.com/CptGibbon/House-of-Corrosion
    - getenv
  - สังเกต instruction ใน assembly และจาก decompiler 

When you know what vulnerability you could use
try it out

--------------
Read Reference 
-------
RelRo : https://ctf101.org/binary-exploitation/relocation-read-only/
About the memory protection : https://mdanilor.github.io/posts/memory-protections/
Dangerous function in C : https://dwheeler.com/secure-programs/Secure-Programs-HOWTO/dangers-c.html#:~:text=C%20users%20must%20avoid%20using,%2C%20and%20gets(3).
Common Memory/Pointer exploit in C : https://www.geeksforgeeks.org/common-memory-pointer-related-bug-in-c-programs/
Format string attack : https://julianor.tripod.com/bc/formatstring-1.2.pdf
Linux Privillege Escalation : https://loveleshgangil.medium.com/linux-privilege-escalation-checklist-6ccfb13b11ca
